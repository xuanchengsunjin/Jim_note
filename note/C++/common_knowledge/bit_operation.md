#### [基础-位运算符](https://www.runoob.com/cprogramming/c-operators.html)
----------------------------------------------------------------------------------------------------

- 下表显示了 C 语言支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：

  |运算符|	描述 | 备注	|实例|
  | --- | --- | --- | --- |
  |&|位与 AND ||A & B) 将得到 12，即为 0000 1100|
  |^|位异或 XOR ||(A ^ B) 将得到 49，即为 0011 0001|
  |&#124;|位或 OR ||(A &#124; B) 将得到 61，即为 0011 1101|
  |<<|左移运算符|二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。|A << 2 将得到 240，即为 1111 0000|
  |>>|右移运算符|二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。|A >> 2 将得到 15，即为 0000 1111|
  |~|取反运算符||(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。|
  
 - 位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

    | p | q |p&q|p &#124; q|p ^ q|
    | --- | --- | --- | --- | --- |
    | 0 | 0 | 0 | 0   | 0 |
    | 0 | 1 | 0 | 1   | 1 |
    | 1 | 1 | 1 | 1   | 0 |
    | 1 | 0 | 0 | 1   | 1 |
    
#### 简单的位操作技巧
--------------------------------------------------------------------------------------------------------
- [ ] 判断奇数,偶数
  - 只要整数的最后一位比特是 1 ，那它就是奇数，反之就是偶数
  ```C++
    if ((x & 1) == 0)
    {
        // x is even
    }
    else
    {
        // x is odd
    }
  ```
  ```bash
    # 从中看到 & 运算怎样擦除了高位的 b7 ～ b1 位的数据只保留了 b0 位，结果为 1，因此知道 43 是奇数。
    1    00101011
    2&   00000001   (note: 1 is the same as 00000001)
    3    --------
    4    00000001
  ```
  
- [ ] 测试第n位比特
  > 测试第任意位比特，只要将与运算的1向左平移相应的位数即可。假设向左平移n位，<br>
  > 接下来的与运算就是只保留第n位，其它位都清零了。
  ```C++
    if (x & (1<<n))
    {
        // n-th bit is set
    }
    else
    {
        // n-th bit is not set
    }
  ```
  - 简单的演示:
  ```bash
    00000001    (same as 1<<0)
    1<<1      00000010
    1<<2      00000100
    1<<3      00001000
    1<<4      00010000
    1<<5      00100000
    1<<6      01000000
    1<<7      10000000
  ```
  
- [ ] 将第n位设为1
  - 只是把与运算（&）换成了或运算（|）。与1进行或运算将参与运算的位置为1，与0进行或运算参与预算的位不变。
  ```C++
    y = x | (1<<n)
  ```
  - 演示:
  ```C++
    1    01111000    (120 in binary)
    2|   00000100    (1<<2)
    3    --------
    4    01111100
  ```
  
- [ ] 将第n位设为0
  - 这个方法的关键就是~(1<<n)，它将第n位设为0，其它位全部为1。看下面：
  ```C++
    y = x & ~(1<<n)
  ```
  - 演示:
  ```C++
    ~1        11111110  (same as ~(1<<0))
    ~(1<<1)   11111101
    ~(1<<2)   11111011
    ~(1<<3)   11110111
    ~(1<<4)   11101111
    ~(1<<5)   11011111
    ~(1<<6)   10111111
    ~(1<<7)   01111111
  ```
  
- [ ] 将第n位取反
  > 这次使用的是异或运算，如果异或运算的两个操作数相同，运算结果是0，两个操作数不同，结果是1。怎样将第n位取反呢？如果第n位比特为1，<br>
  > 将它与1进行异或运算结果就是0，如果它是0，那么它与1异或运算的结果就是1。于是这一位就取反了。
  ```C++
    y = x ^ (1<<n)
  ```
  - 演示
  ```bash
    1    01110101
    2^   00100000
    3    --------
    4    01010101
    
    1    01010101
    2^   00100000
    3    --------
    4    01110101
  ```
