#### 前言
-------------------------------------------------------------------------------------
- [ ] cpu传输数据的方式：<br>

> cpu每次传输数据大小由它的总线条数决定，32位传输4个字节，64位传输8个字节。<br>
> 这里以64位系统举例，若声明一个变量大小为8字节，起始地址位1，而cpu读取的地址为0~7，则该变量需要读取两次，显然降低了cpu的性能。<br>           

-  [ ] 补齐策略:<br>

> 为提高cpu读取的性能，采用补齐的方法提高cpu的效率。即内存为8字节的数据，一定会被一次读取，这当然需要调整变量在内存中的起始地址，<br>
> 使其从0开始。若一个变量不满足8字节，则进行补齐，保证其后一个变量的地址满足cpu读取的初始地址。<br><br>
> 补齐：为保证cpu每次读取都是从初始地址开始，对长度不满足8字节的变量进行补全。<br>

- [ ] 结构体的补全规则如下：
<div align="center">
    <img src="https://github.com/xuanchengsunjin/Jim_note/blob/sandbox/resource/img/C%2B%2B/struct_memorary.png" width="500px">
</div>
<br>

```bash
结构体A:

第一个变量是char类型，大小为1字节，第二个变量是double，是8个字节。

以大字节为单位进行补齐，将char补齐为8个字节。

第三个变量是int，为4个字节，按照8字节单位进行补齐为8字节。

共占用32字节。

 

结构体B：

第一个变量是double，占8字节

第二个变量为char，占一个字节，对char进行补齐，为8个字节，char只占用一个字节，后面为补位。

而剩下的字节可以放下int，因此不用再对int进行分配字节，共占据两个字节。

 

结构体C：

第一个变量是int，占4个字节。

第二个为char，占一个字节，要对char进行补齐，补齐为4个字节（按照结构体中内存最大的类型为单位进行补齐）。

第三个为double，占8个字节，按八个字节进行补齐操作。
```
- [ ] 结论：不难发现，内存的分配，不仅数据类型相关，还和变量声明的顺序相关。

#### 笔试题
------------------------------------------------------------------------------------------------
- [ ] 谁更适合:
- 结构体的定义，在32位操作系统里面，以下的结构体定义哪个更好，为什么?
```C++
    // 第一种:
    typedef struct _Udata_Info_T1{
       int num;
       short peak_2nd;
       char peak;
    }Udata_Info_T1;
    
    //第二种:
    typedef struct _Udata_Info_T2{
       char peak;
       int num;
       short peak_2nd;
    }Udata_Info_T2;
```
