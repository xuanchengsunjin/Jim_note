#### C/C++内存模型

  - [ ] [C++内存模型](https://www.cnblogs.com/fenghuan/p/4778050.html)
    - 1.栈: 就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。
    - 2.堆: 就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
    - 3.自由存储区: 就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
    - 4.全局/静态存储区: 全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
    - 5.常量存储区: 这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）
    
  - [ ] [C内存模型](https://www.nowcoder.com/questionTerminal/c266ce32cb2e406284eb02710cac3e0a)
    - 1.栈: 由编译器自动分配释放
    - 2.堆: 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收
    - 3.全局区/静态区: 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束释放
    - 4.常数区: 一个专门放常量的地方。- 程序结束释放
    - 5.代码区: 存放函数体的二进制代码。
    > 举例:
    ```C++
      #include <stdlib.h>
      #include <string.h>
      int a = 0; // 全局初始化区
      char* p1;  // 全局未初始化区
      int main() {
          int a;            // 栈区
          char s[] = "abc"; // 栈区
          char* p2;         // 栈区
          char* p3 = "123456";    // 123456\0在常量区，p3在栈区
          static int c = 0;      // 全局/静态初始化区
          p1 = (char*) malloc(10);
          p2 = (char*) malloc(20); // 分配得来的10和20字节在堆区
          strcpy(p1, "123456"); // 123456\0放在常量区，编译器可能将它与p3所指向的"123456"优化成一个地方
          return 0;
      }
    ```
    
    - [图解](https://blog.csdn.net/jirryzhang/article/details/79518408)
    <div align="center">
       <img src="https://github.com/xuanchengsunjin/Jim_note/edit/sandbox/resource/img/C++/memorary.png" width="300px">
    </div>
    <br>
    
    > 表1:栈和堆的对比:

      ||栈|堆|
      | --- | --- | --- |
      |存储内容| 局部变量| 变量|
      |作用域	|函数作用域、语句块作用域| 函数作用域、语句块作用域|
      |编译期间大小是否确定	|是| 否|
      |大小| 1MB |    4GB|
      |内存分配方式	|    地址由高向低减少|    地址由低向高增加|
      | 内容是否可以修改	|    是|    是|
    
    > 表2 全局/静态存储区和常量存储区的对比:
    
      ||全局/静态存储区| 常量存储区|
      | --- | --- | --- |
      |存储内容|      全局变量、静态变量|      常量|
      | 编译期间大小是否确定|  是|      是|
      |      内容是否可以修改|      是|      |
      
      
#### C++内存管理
-------------------------------------------------------------------------------------------------------------------
  - [ ] [基础解析](https://www.runoob.com/cplusplus/cpp-dynamic-memory.html)
  - [ ] [new(动态内存) & malloc区别](https://www.cnblogs.com/QG-whz/p/5140930.html):
  
    |特征	|new/delete	|malloc/free|
    | --- | --- | --- |
    |分配内存的位置|	自由存储区	|堆|
    |内存分配成功的返回值|	完整类型指针	|void*|
    |内存分配失败的返回值	|默认抛出异常|	返回NULL|
    |分配内存的大小	|由编译器根据类型计算得出	|必须显式指定字节数|
    |处理数组|	有处理数组的new版本new[]	|需要用户计算数组的大小后进行内存分配|
    |已分配内存的扩充	|无法直观地处理	|使用realloc简单完成|
    |是否相互调用	|可以，看具体的operator new/delete实现	|不可调用new|
    |分配内存时内存不足	|客户能够指定处理函数或重新制定分配器	|无法通过用户代码进行处理|
    |函数重载|	允许	|不允许|
    |构造函数与析构函数|	调用	|不调用|
    
  - [ ] delete & delete[] 区别:
    
    |delete|delete[]|
    | --- | --- |
    |代表用来释放内存，且只用来释放ptr指向的内存|用来释放rg指向的内存，！！还逐一调用数组中每个对象的 destructo|
    
    ```C++
    class A
    {
        private:
            char *m_cBuffer;
            int m_nLen;
        public:
            A(){ m_cBuffer = new char[m_nLen]; }
            ~A() { delete [] m_cBuffer; }
    };
    A *a = new A[10];

    // 仅释放了a指针指向的全部内存空间 但是只调用了a[0]对象的析构函数 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏
    delete a;

    // 调用使用类对象的析构函数释放用户自己分配内存空间并且   释放了a指针指向的全部内存空间
    delete [] a;
    ```
    
#### C语言内存管理
-------------------------------------------------------------------------------------------------------------------
  - [ ] [基础解析](https://www.runoob.com/cprogramming/c-memory-management.html)
